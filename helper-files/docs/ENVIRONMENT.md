# Environment Variables in Worker Services

This document explains **where** service-level environment variables are defined and **how** they can be accessed inside Cloudflare Worker services within the `services/` workspace.

---

## 1. Where to Define Environment Variables

1. **Non-secret variables** – define once in the service’s `wrangler.toml` under the `vars` table.

   ```toml
   # services/<service-name>/wrangler.toml
   [vars]
   PUBLIC_API_BASE = "https://api.example.com"
   RUNTIME_MODE    = "production"
   
   # Optional deployment-specific overrides
   [env.staging.vars]
   RUNTIME_MODE = "staging"
   ```

2. **Secrets** – store securely with the Wrangler CLI. These are **not** committed to the repo.

   ```bash
   # From the service directory
   wrangler secret put MY_SECRET_KEY
   ```

   Wrangler creates an encrypted binding that is exposed at runtime via the same `env` object as normal variables.

---

## 2. How Variables Reach Your Worker

Cloudflare injects all `[vars]` and secret bindings into the Worker module at runtime under the special `env` object.

### 2.1 Direct Import (recommended for quick access)

```js
import { env } from "cloudflare:workers";

console.log(env.RUNTIME_MODE); // ⇒ "production" or override
```

### 2.2 Constructor Injection via `WorkerEntrypoint`

```js
import { WorkerEntrypoint } from "cloudflare:workers";

export default class Service extends WorkerEntrypoint {
  constructor(ctx, env) {
    super(ctx, env);
    // `env` is available here as well
  }
}
```

### 2.3 Runtime Parameters from Serverless API Gateway (SAG)

When a Worker method is invoked **through** the Serverless API Gateway, the gateway serialises the **caller’s environment** and passes it as the second argument (`caller_env`) to the handler together with a **SAG context** object in the third argument (`sagContext`).

```js
import { env } from "cloudflare:workers";

/**
 * Generic signature expected by the API Gateway
 */
async handler(request, caller_env = "{}", sagContext = "{}") {
  // env         → This service’s own bindings (objects & secrets)
  // caller_env  → JSON string containing the API Gateway worker environment
  // sagContext  → JSON string containing gateway-generated request context

  // Example: just log the raw strings (avoid parsing in docs)
  console.log({ env, caller_env, sagContext });
}
```

- `env` originates from the **service’s own** `wrangler.toml` bindings (and any secrets added via `wrangler secret`).
- `caller_env` originates from **`wrangler.api.toml`** of the Serverless API Gateway and contains its bindings, secrets, and service bindings.
- `sagContext` is generated by the gateway at runtime and contains metadata such as the matched path config, the original request URL, auth payloads, etc.

---

## 3. Example Data Structures

Below are trimmed examples for each object type to illustrate typical shapes and contents.  **Never commit real secrets to source control.**

### 3.1 `env`

```json
{
  "FAX_FILES_BUCKET": {},
  "LOG_LEVEL": "DEBUG",
  "TEST_VARIABLE": "hello-from-staging"
}
```

### 3.2 `caller_env`

```json
{
  "CONFIG": {},
  "ENV_TEST_SERVICE": {},
  "FAX_SERVICE": {},
  "LOG_LEVEL": "DEBUG",
  "NOTIFYRE_API_KEY": "<redacted>",
  "SUPABASE_URL": "https://vqdpahsrwtaccjozuchj.supabase.co",
  "SUPABASE_ANON_KEY": "<redacted>",
  "TELNYX_API_KEY": "<redacted>"
}
```

### 3.3 `sagContext`

```json
{
  "apiConfig": {
    "$schema": "https://raw.githubusercontent.com/irensaltali/serverlessapigateway/main/src/api-config.schema.json",
    "title": "API Gateway Config",
    "servers": [
      {
        "alias": "serverlessapigateway-api",
        "url": "https://example.ngrok-free.app"
      }
    ]
    // … additional API-level configuration …
  },
  "requestUrl": "https://api-staging.sendfax.pro/v1/some-service/debug",
  "jwtPayload": null,
  "matchedPath": {
    "config": {
      "method": "GET",
      "path": "/v1/some-service/debug",
      "integration": {
        "type": "service_binding",
        "binding": "some_service",
        "function": "debug"
      },
      "auth": false
    },
    "matchResult": {
      "matchedCount": 4,
      "isExact": true,
      "params": {}
    }
  }
}
```

---

## 4. Best Practices

1. **Never log secrets** in production.  Logging the full environment is acceptable only in dedicated debugging endpoints.
2. **Keep variable names consistent** across services to avoid confusion (e.g. always use `RUNTIME_MODE`, not `MODE` in one service and `ENV` in another).
3. **Use feature flags sparingly**, as per project rules.  Centralise flags and validate expected values at runtime.
4. **Document new variables** in each service’s `README` or in this file to help future maintainers.

---

## 5. Troubleshooting

| Symptom | Likely Cause | Fix |
|---------|--------------|-----|
| `env` is `undefined` | Running code outside a Worker context (e.g. unit test) | Stub the `env` object or inject via constructor when testing |
| `JSON.parse` fails on `caller_env` | Caller sent non-JSON payload | Inspect raw string and adjust gateway mapping |
| Secrets not available | Secret not added in Wrangler | Run `wrangler secret put <NAME>` in the service directory | 
